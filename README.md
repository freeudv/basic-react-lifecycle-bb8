## Component Lifecycle Methods

Доброго времени суток, меня зовут Артем и добро пожаловать на JavaScript Ninja.

Сегодня мы с вам поговорим про одну из фундаментальных вещей в React, а именно - про Component Lifecycle(с бурж. жизненный цикл компонента).

И рассмотрим мы эту тему на примере простой игры,
суть которой заставить BB8 пройти весь путь, не столкнувшись с ящиками.

`* показывает начальный скрин *`

## Прилюдия

Для начала давайти рассмотрим из чего будет состоять наша игра.
У нас есть 3 компонента: `BB8`, `Battlefront` и `Box`

`* открывает BB8/index.js *`

`BB8` на вход принимает следующие параметры:

* box - ящик, к какому приблизился дроид
* end - закончилась ли игра

И имеет два поля в состоянии:

* up - находится ли дроид в воздухе
* move - двигается ли дроид

`* открывает Battlefront/index.js *`

`Battlefront` - основной компонент, в котором происходит логика отрисовки мира и он , в свою очередь содержит только состояние, в которое входят:

* boxes - ящики, которые в данный момент находятся на поле
* boxNear - ящик, которы находится рядом с BB8
* end - закончилась ли игра

`* открывает Box/index.js *`

`Box` - обычный функциональный компонент, которы ждет в `props`:

* left - текущее положение на оси `X`
* top - текущее положение на оси `Y`
* size - `width` и `height` ящика

Надеюсь это не сильно засорило вам мозг.

И все же продолжим.

`* листает слайд *`

## Component Lifecycle

Каждый компонент проходит несколько этапов своего существования:

* До первого рендера
* Первый рендер
* Последующие обновления состояния и атрибутов
* Удаление компонента из Virtual DOM
* Ошибка при отрисовке

React как библиотека предоставляет нам набор методов, благодаря которым, мы можем поймать тот или иной момент жизненного пути компонента.

Всего существует 8.5 методов, которые помогут вам в написании элегантных компонентов.

`* листает слайд *`

## componentWillMount и constructor

Первыми двумя взаимозаменяемыми методами жизненного цикла являются `componentWillMount` и `constructor`

Эти методы гарантированно выполнятся до первого рендера компонента.

`componentWillMount` был создан до того, как появились class components, и был единственным методом для обработки данных перед первым рендером, сейчас же разработчики React рекомендуют использовать `constructor`, а `componentWillMount` использовать только при SSR, с которым Вы познакомитесь на продвинутом курсе, так что в рамках этого курса мы с вами рассмотрим `constructor` как метод жизненного цикла.

`* открывает BB8/index.js *`

Давайте для начала заставим нашего дроида двигаться:

`* пишет constructor в BB8 component *`

Как видно из нашего кода, constructor используется для инициализации начального состояния компонента.
Стоит также сказать, что благодаря такому инструменту как Babel, мы можем писать переменные прям в классе, и он(Babel) переместит их в конструктор, но Вы не можете использовать эту плюшку, если Ваше начальное состояние зависит от props, которые приходят на момент инициализации Вашего компонента.

Вжух, и наш дроид движется, но где же его препятствия?

В этом нам поможет следующий метод жизненного цикла, а именно `componentDidMount`

## componentDidMount

`componentDidMount` срабатывает сразу после первого рендера компонента и является местом для вызова асинхронных функций и инициализации подписок, также в отличии от `constructor` и `componentWillMount` `setState` будет вызывать ререндер компонента.

Давайте посмотрим на этот метод на примере:

`* открывает Battleground/index.js *`

Усложним жизнь нашего дроида и добавим препятствия.

`* пишет componentDidMount с вызовом 'addNewBox' и 'setInterval' *`

В данном методе мы создали две "подписки":

* 1. Добавляет новые ящики на поле
* 2. Меняет их положение

## componentWillUnmount

Вторым из и частои спользуемых методов является `componentWillUnmount`.
Данный метод вызывается непосредственно перед уничтожением компонента из DOM-дерева и используется для очистки подписок(таймаутов, observables, DOM events).

В нашем случае нам этот метод пригодится для очистки интервалов, на которые мы подписались в предыдущем примере.

`* открывает Battleground/index.js и пишет 'componentWillUnmount' *`

Замечательно, наш мир жив и двигается(дергается), но наш дроид проезжает ящики без каких либо последствий... НЕХОРОШО!

## componentDidUpdate и componentWillUpdate

`* открывает BB8/index.js *`

Поскольку мы передаем ближайший ящик в props нашему маленькому дроиду, давайте начнем отслеживать столкнулся ли BB8 с препятствием или нет путем простых правил:

* Если ящик внизу и в состоянии нашего юнита атрибут `up` выставлен в `false` - дроид столкнулся с ящиком
* Если ящик вверху и в состоянии нашего юнита атрибут `up` выставлен в `true` - дроид столкнулся с ящиком
* Иначе дроид прошел препятствие

Проблема состоит в том, что нам нужно гарантировать, что обновления произошло, перед тем, как проверять наши правила.
В этом нам поможет `componentDidUpdate`

`componentDidUpdate` это тоже метод жизненного цикла, который выполняется сразу после рендера компонента, и принимает в аргументы предыидущие `props` и `state`, то есть `state` и `props`, которые были до рендера.
Также в React присутствует схожий метод - `componentWillUpdate`, который вызывается перед обновлением, и принимает в аргументы новые `props` и `state`,
но мы не будем рассматривать этот метод в рамках этого видео, так как вы познакомитесь с ним поподробней на занятии связанным с DOM-интеграциями.

Стоит лишь упомянуть, что в отличии от `componentDidUpdate`, в `componentWillUpdate` вы не можете вызывать `setState`.

Также не будет лишним уточнить, что хоть вы и можете вызвать `setState` в `componentDidUpdate`, это является антипаттерном, то есть этот прием не рекомендуется к использованию.

Но продолжим мучить BB8.

`* говнокодит *`

Ура! Мы сломали жизнь BB8.

Но погодите ка, что за много красных буков у меня в консоли?

`* показывает Maximum update depth exceeded. *`

Почему же так получилось?

Дело в том, что каждый раз как наш компонент обновляется и удволетворяет нашему условию, он обновляет `state` родительского компонента, а тот в свою очередь прокидывает его в `props` и у нас получается своего рода рекурсия без условия ее окончания. Мы могли бы проверять в `compoentnDidUpdate` предыидущие `props` и увеличить в два раза наше условие, но есть способ более элегантный.

## shouldComponentUpdate

Что бы исправить эту ошибку нам нужно рассмотреть еще один lifecycle method - `shouldComponentUpdate`

Этот метод часто используется для оптимизаций и исключения лишних рендеров компонетна.
Он вызывается перед рендером и принимает следующие `state` и `props`.

Суть этого метода заключается в том, что он должен возвращать `true` или `false`, в зависимости нужно нам перерисовывать компонент или нет:

То есть если мы вернули `false` - то методы `componentWillUpdate`, `render`, и `componentDidUpdate` не будут вызваны.

Давайте попробуем исправить наше исключение с помощью этого метода:

`* пишет shouldComponentUpdate в файле BB8/index.js *`

Давайте взглянем на консоль теперь.

`* смотрит на консоль *`

Ошибка пропала, потому что мы исключили ненужные ререндеры нашего компонента.

## componentWillReceiveProps

Но теперь перед нами появилась новая задача: "Заставить дроида избегать препятствий"

И Вы должно быть спросите: "Артем, а есть ли метод, который вызывается после смены props на компоненте в котором можно вызывать `setState` ?"

А я отвечу: "Да. и имя его `componentWillReceiveProps`"

`* закрывает ноутбук и уходит *`

`componentWillReceiveProps` один из самых полезных методов жизненного цикла компонент.
Он тригерится при прокидывании новых или изменении старых `props` и принимает в аргументы обновленные `props`.

И, самое главное, он разрешает нам использовать `setState` внутри себя.

Стоит заметить, что React может вызывать этот метод, даже если `props` не изменились, так что правилом хорошего тона является делать проверки на изменения полей в `props`, которые Вас интересуют.

Также нелишним будет сказать и о том, что `componentWillReceiveProps` не вызывается перед первым рендером.

Давайте добавим логику уклонений для нашего дроида.

`* открывает файл BB8/index.js и пишет componentWillReceiveProps *`

И теперь наш дроид является полноценным членом общества.

## componentDidCatch

Также стоит немного рассказать про новый метод, который появился в `React 16` - `componentDidCatch`

Этот метод срабатывает, если внутри `children` компонента возникла `runtime-ошибка`, и принимает экземпляр исключения и стек вызова.

С помощью него Вы можете делать обработку ошибок на уровне представления.
Давайте рассмотрим на примере.

`* открывает Exception/index.js *`

Данный компонент не занимается ничем, кроме отрисовки `children`, но если в них происходит исключение, он отрисовывает имя исключения и стэк вызова.
Давайте рассмотрим наглядно и специально допустим ошибку внутри одного из компонентов.

`* открывает Battlefront/index.js и удаляет букву 'p' из boxes.map... *`

Как Вы видите, мы получаем простой компонент, способный показать суть ошибки и ее место, но на `production` лучше выводить что-то не пугающее обычного пользователя. Например следующее:

`* меняет Exception на ProdExcetpion в файле main.js *`

И пользователь счастлив.

`* меняет слайд презентации *`

## Method sequence

Давайте закрепим последовательность методов:

`* тем временем на презентации последовательность методов *`

* И так, сначала перед рендером у нас вызываются `constructor` и `componentWillMount`
* Потом вызывается `render`
* После первого рендера мы попадаем в `componentDidMount`
* И дальше будет повторятся последовательность состоящая из:
  * `componentWillReceiveProps`
  * `shouldComponentUpdate`
  * `componentWillUpdate`
  * `render`
  * `componentDidUpdate`
    Пока мы не получим ошибку, в случае чего вызовется `componentDidCatch`, или пока не удалим наш компонент и попадем в `componentWillUnmount`

## Summary

Давайте подсумируем

Как только наш компонент попадает в дерево элементов реакта - он начинает бурную деятельность в виде сообщения своего жизненного этапа.
Мы можем отследить каждый из этих этапов путем определения методов жизненного цикла внутри компонента, таких как:

* `constructor`
* `componentWillMount`
* `componentDidMount`
* `componentWillReceiveProps`
* `shouldComponentUpdate`
* `componentWillUpdate`
* `componentDidUpdate`
* `componentDidCatch`
* `componentWillUnmount`

Благодаря использованию данных методов мы можем строить лаконичные и независимые компонента, которые могу не только работать с Вашим API, или подписываться на события WebSocket, но и нестандартно реагировать на изменение `props`.

На сей ноте хочу закончить мой рассказ, увидимся с вами в следующих видео.

До встречи и да прибудет с вами сила.
